{"version":3,"file":"component---src-pages-index-3-tsx-293a35c50ad17090fd9e.js","mappings":"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","sources":["webpack://gatsby-starter-default/./src/components/ProtectedRoute.tsx","webpack://gatsby-starter-default/./src/api/server.tsx","webpack://gatsby-starter-default/./src/api/twilio.tsx","webpack://gatsby-starter-default/./src/api/websocket.tsx","webpack://gatsby-starter-default/./src/pages/index3.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport { onAuthStateChanged } from \"firebase/auth\";\nimport { navigate } from \"gatsby\";\nimport { auth } from \"../firebase/firebase-config\";\n\nconst ProtectedRoute = ({ children }: { children: (user: any) => React.ReactNode }) => {\n  const [user, setUser] = useState<any>(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {\n      if (currentUser) {\n        setUser(currentUser); // Set the authenticated user\n      } else {\n        navigate(\"/login\"); // Redirect to login if not authenticated\n      }\n      setLoading(false); // Set loading to false after checking auth state\n    });\n\n    // Cleanup the subscription when the component is unmounted\n    return () => unsubscribe();\n  }, []);\n\n  if (loading) {\n    // You can return a loading spinner or message here\n    return <p>Loading...</p>;\n  }\n\n  return user ? children(user) : null; // Only render children if the user is authenticated\n};\n\nexport default ProtectedRoute;","import React, { useEffect, useRef, useState } from \"react\";\n\n// âœ… Reconnection Strategy (High Priority for Sales Calls)\n// - MAX_RECONNECT_DELAY (30s) prevents excessive retries but **is too long for sales**â€”lowering it ensures quicker recovery.\n// - BASE_RECONNECT_DELAY (5s) ensures fast reconnections, but if the server is unstable, rapid retries could cause rate limits or bans.\n// - Recommended: **Set MAX_RECONNECT_DELAY lower (e.g., 10s-15s)** to reduce downtime and avoid missed calls.\n// - If connection is restored, **reset the backoff immediately** to ensure responsiveness.\n// - Consider **alerting the user if reconnection fails** (e.g., push notification, UI warning) instead of silently retrying forever.\n\nconst MAX_RECONNECT_DELAY = 15000; // Max delay: 15 seconds\nconst BASE_RECONNECT_DELAY = 5000; // Initial delay: 5 seconds\nconst MAX_ATTEMPTS_BEFORE_ALERT = 5; // Alert after 5 failed attempts\nconst DOMAIN : string = 'makethemcall.me'\n\n\nconst reconnectWS = ({ \n  wsRef, \n  url, \n  baseReconnectDelay, \n  maxReconnectDelay, \n  reconnectAttemptsRef, \n  maxAttemptsBeforeAlert \n}: any) => {\n  \n  if (wsRef.current) {\n    wsRef.current.close();\n  }\n\n  const delay = Math.min(baseReconnectDelay * Math.pow(2, reconnectAttemptsRef.current), maxReconnectDelay);\n\n  reconnectAttemptsRef.current += 1;\n\n  // Alert after reaching max attempts\n  if (reconnectAttemptsRef.current >= maxAttemptsBeforeAlert) {\n    console.warn(`WebSocket reconnection failed ${maxAttemptsBeforeAlert} times. Please check the server.`);\n  }\n\n  setTimeout(() => {\n    wsRef.current = new WebSocket(url);\n    \n    wsRef.current.onopen = () => {\n      reconnectAttemptsRef.current = 0;\n    };\n  }, delay);\n};\n\n\n//const [isConnected, setIsConnected] = useState(false);\nconst connectWS = ({ \n  wsRef, \n  url, \n  reconnectAttemptsRef, \n  onMessageReceived,\n  onError,\n  onOpen,\n  onClose,\n}: {\n  wsRef: any; \n  url: any; \n  reconnectAttemptsRef: any;\n  onMessageReceived?: any; \n  onError?: any; \n  onOpen?: any; \n  onClose?: any; \n}) => {\n    if (wsRef.current) {\n        wsRef.current.close(); // Ensure previous WebSocket is closed\n    }\n\n    wsRef.current = new WebSocket(url);\n\n    wsRef.current.onopen = () => {\n        console.log(\"âœ… WebSocket connected\");\n        reconnectAttemptsRef.current = 0; // Reset attempts on success\n        if (onOpen) onOpen();\n    };\n\n    wsRef.current.onmessage = (event: any) => {\n        if (onMessageReceived) {\n            onMessageReceived(event);\n        } else {\n            try {\n                const data = JSON.parse(event.data);\n                console.log(\"ðŸ“© New message:\", data);\n            } catch (err) {\n                console.error(\"âŒ Failed to parse WebSocket message:\", err);\n            }\n        }\n    };\n\n    wsRef.current.onerror = (error: any) => {\n        if (onError) {\n            onError(error);\n        } else {\n            console.error(\"âŒ WebSocket Error:\", error);\n            reconnectWS({ \n                wsRef, \n                url, \n                reconnectAttemptsRef,\n                baseReconnectDelay: BASE_RECONNECT_DELAY, \n                maxReconnectDelay: MAX_RECONNECT_DELAY,  \n                maxAttemptsBeforeAlert: MAX_ATTEMPTS_BEFORE_ALERT\n            });\n        }\n    };\n\n    wsRef.current.onclose = () => {\n        if (onClose) {\n            onClose();\n        } else {\n            console.log(\"ðŸ”´ WebSocket disconnected. Reconnecting...\");\n            reconnectWS({ \n                wsRef, \n                url, \n                reconnectAttemptsRef,\n                baseReconnectDelay: BASE_RECONNECT_DELAY, \n                maxReconnectDelay: MAX_RECONNECT_DELAY,  \n                maxAttemptsBeforeAlert: MAX_ATTEMPTS_BEFORE_ALERT\n            });\n        }\n    };\n};\n\n\nexport const useWebSocket = (url: string) => {\n  const [incomingSms, setIncomingSms] = useState<string[]>([]);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n\n  useEffect(() => {\n      connectWS({\n          wsRef,\n          url,\n          reconnectAttemptsRef,\n          onMessageReceived: (event : any ) => {\n              try {\n                  const data = JSON.parse(event.data);\n                  setIncomingSms((prev) => [...prev, data]);\n              } catch (err) {\n                  console.error(\"âŒ Failed to parse WebSocket message:\", err);\n              }\n          }\n      });\n\n      return () => wsRef.current?.close(); // Cleanup WebSocket on unmount\n  }, [url]); // Reconnect if the URL changes\n\n  return { incomingSms };\n};\n\n\n\nexport async function getTwilioClient() {\n    try {\n      const Twilio = await import(\"twilio-client\");\n      return Twilio;\n    } catch (error) {\n      console.error(\"Failed to load Twilio Client:\", error);\n      return undefined;\n    }\n}\n\nexport const fetchTwilioToken = async ({ user } : any ) => {\n    try {\n\n      const token = await user.getIdToken();\n      const response = await fetch(`https://${DOMAIN}/api/generate-token`, {\n        method: \"POST\",\n        headers: { \n          \"Content-Type\": \"application/json\",\n     \n          \"Authorization\": `Bearer ${ token }`  // âœ… Include token\n        \n        },\n        body: JSON.stringify({ identity: \"the_user_id\" }),\n      });\n\n      if (!response.ok) throw new Error(\"Failed to fetch token\");\n      const data = await response.json();\n      console.log(`ðŸ”‘ Token: ${data.token}`);\n      return data.token\n    } catch (error) {\n      console.log(\"ðŸš¨ Could not get a token from server!\");\n    }\n};\n\nexport const makeTwilioCall = async ({ user, phoneNumber}:any) => {\n    try {\n      const token = await user.getIdToken();\n      const response = await fetch(`https://${DOMAIN}/api/make-call`, {\n        method: \"POST\",\n        headers: { \n          \"Content-Type\": \"application/json\",\n          \"Authorization\": `Bearer ${ token }`  // âœ… Include token\n        },\n        body: JSON.stringify({ to: phoneNumber }),\n      });\n\n      const result = await response.json();\n      if (!response.ok) throw new Error(result.error || \"Failed to make call\");\n      console.log(`ðŸ“ž Calling ${phoneNumber}...`);\n    } catch (error) {\n      console.log(`âš ï¸ Call error: ${(error as any).message}`);\n    }\n};\n\n\nexport const sendTwilioSms = async ({ user, phoneNumber, smsMessage, setLog, setSmsMessage }:any) => {\n    try {\n      const token = await user.getIdToken();\n      const response = await fetch(`https://${DOMAIN}/api/send-sms`, {\n        method: \"POST\",\n        headers: { \n          \"Content-Type\": \"application/json\",\n          \"Authorization\": `Bearer ${ token }`  // âœ… Include token\n        },\n        body: JSON.stringify({ to: phoneNumber, message: smsMessage }),\n      });\n\n      const result = await response.json();\n      if (!response.ok) throw new Error(result.error || \"Failed to send SMS\");\n\n      setLog((prev : any ) => [...prev, `Sent: ${smsMessage} to ${phoneNumber}`]);\n      setSmsMessage(\"\");\n    } catch (error) {\n      console.log(`âŒ SMS Error: ${(error as any).message}`);\n    }\n};\n\nexport const hangUp = ({ device } : any ) => {\n    if (device) {\n        console.log(\"ðŸ”´ Hanging up...\");\n        device.disconnectAll();\n    }\n};\n\nexport const answerCall = ({ incomingConnection, setIsConnected } : any ) => {\n    if (incomingConnection) {\n        console.log(\"âœ… Answering call...\");\n        incomingConnection.accept();\n        setIsConnected(true);\n    }\n};\n\nexport const rejectCall = ({ incomingConnection, setIncomingConnection } : any ) => {\n    if (incomingConnection) {\n      console.log(\"âŒ Rejecting call...\");\n      incomingConnection.reject();\n      setIncomingConnection(null);\n    }\n};\n \n\n","import React, { useEffect, useState } from \"react\";\nimport { getTwilioClient } from \"./server\";\n\nexport const getCurrentTwilioUserId = ( identity ?: any ) => identity || \"the_user_id\";  \n\n\n\n\nexport const Twilio = ({ children }: { children: (client: any) => React.ReactNode }) => {\n  const [twilioClient, setTwilioClient] = useState<any>(undefined);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchTwilioClient = async () => {\n      try {\n        const twilio = await getTwilioClient();\n        setTwilioClient(twilio);\n        setLoading(false);\n      } catch (error) {\n        console.error(\"Error fetching Twilio client:\", error);\n        setLoading(false);\n      }\n    };\n\n    if (!twilioClient) {\n      fetchTwilioClient();\n    }\n  }, [twilioClient]);\n\n  if (loading) return <p>Loading...</p>;\n\n  return <>{twilioClient ? children(twilioClient) : null}</>;\n};\n","import React, { useEffect, useRef, useState } from \"react\";\n\nconst MAX_RECONNECT_DELAY = 15000; // Max delay: 15 seconds\nconst BASE_RECONNECT_DELAY = 5000; // Initial delay: 5 seconds\nconst MAX_ATTEMPTS_BEFORE_ALERT = 5; // Alert after 5 failed attempts\nconst DOMAIN : string = 'makethemcall.me'\nconst WEBSOCKET_URL : any = `wss://${DOMAIN}/ws/`\n\n\nconst reconnectWS = ({ \n  wsRef, \n  url, \n  baseReconnectDelay, \n  maxReconnectDelay, \n  reconnectAttemptsRef, \n  maxAttemptsBeforeAlert \n}: any) => {\n  \n  if (wsRef.current && wsRef.current.readyState !== WebSocket.CLOSED) {\n    wsRef.current.close();\n  }\n\n  const delay = Math.min(baseReconnectDelay * Math.pow(2, reconnectAttemptsRef.current), maxReconnectDelay);\n  reconnectAttemptsRef.current += 1;\n\n  if (reconnectAttemptsRef.current >= maxAttemptsBeforeAlert) {\n    console.warn(`WebSocket reconnection failed ${maxAttemptsBeforeAlert} times. Please check the server.`);\n  }\n\n  setTimeout(() => {\n    wsRef.current = new WebSocket(url);\n    \n    wsRef.current.onopen = () => {\n      console.log(\"âœ… WebSocket reconnected\");\n      reconnectAttemptsRef.current = 0;\n    };\n  }, delay);\n};\n\n\nconst connectWS = ({ \n  wsRef, \n  url, \n  reconnectAttemptsRef, \n  onMessageReceived,\n  onError,\n  onOpen,\n  onClose,\n}: {\n  wsRef: any; \n  url: any; \n  reconnectAttemptsRef: any;\n  onMessageReceived?: (event: MessageEvent) => void; \n  onError?: (error: Event) => void; \n  onOpen?: () => void; \n  onClose?: () => void; \n}) => {\n    if (wsRef.current && wsRef.current.readyState !== WebSocket.CLOSED) {\n        wsRef.current.close();\n    }\n\n    wsRef.current = new WebSocket(url);\n\n    wsRef.current.onopen = () => {\n        console.log(\"âœ… WebSocket connected\");\n        reconnectAttemptsRef.current = 0; \n        if (onOpen) onOpen();\n    };\n\n    wsRef.current.onmessage = (event: MessageEvent) => {\n        if (onMessageReceived) {\n            onMessageReceived(event);\n        } else {\n            try {\n                const data = JSON.parse(event.data);\n                console.log(\"ðŸ“© New message:\", data);\n            } catch (err) {\n                console.error(\"âŒ Failed to parse WebSocket message:\", err);\n            }\n        }\n    };\n\n    wsRef.current.onerror = (error: Event) => {\n        if (onError) {\n            onError(error);\n        } else {\n            console.error(\"âŒ WebSocket Error:\", error);\n            reconnectWS({ \n                wsRef, \n                url, \n                reconnectAttemptsRef,\n                baseReconnectDelay: BASE_RECONNECT_DELAY, \n                maxReconnectDelay: MAX_RECONNECT_DELAY,  \n                maxAttemptsBeforeAlert: MAX_ATTEMPTS_BEFORE_ALERT\n            });\n        }\n    };\n\n    wsRef.current.onclose = () => {\n        if (onClose) {\n            onClose();\n        } else {\n            console.log(\"ðŸ”´ WebSocket disconnected. Reconnecting...\");\n            reconnectWS({ \n                wsRef, \n                url, \n                reconnectAttemptsRef,\n                baseReconnectDelay: BASE_RECONNECT_DELAY, \n                maxReconnectDelay: MAX_RECONNECT_DELAY,  \n                maxAttemptsBeforeAlert: MAX_ATTEMPTS_BEFORE_ALERT\n            });\n        }\n    };\n};\n\n\nexport const useWebSocket = (url: string) => {\n  const [incomingSms, setIncomingSms] = useState<string[]>([]);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n\n  useEffect(() => {\n      connectWS({\n          wsRef,\n          url,\n          reconnectAttemptsRef,\n          onMessageReceived: (event: MessageEvent) => {\n              try {\n                  const data = JSON.parse(event.data);\n                  setIncomingSms((prev) => [...prev, data]);\n              } catch (err) {\n                  console.error(\"âŒ Failed to parse WebSocket message:\", err);\n              }\n          }\n      });\n\n      return () => {\n          if (wsRef.current) {\n              wsRef.current.close();\n          }\n      };\n  }, [url]); \n\n  return { incomingSms };\n};\n\n\n\n\n\n  //   export const useWebSocketWithMissingMessages = ({ twilioUserId, wsonly, url }: any) => {\n  //     const [messages, setMessages] = useState<any[]>([]);\n  //     const [incomingSms, setIncomingSms] = useState<any[]>([]);\n  //     const [systemMessages, setSystemMessages] = useState<any[]>([]);\n  //     const [hasFetchedMissing, setHasFetchedMissing] = useState(false); // Prevents duplicate fetches\n  \n  //     // Fetch missing messages from the backend only once\n  //     const fetchMissingMessages = async (twilioUserId: string) => {\n  //         if (hasFetchedMissing) return []; // Prevent duplicate calls\n  \n  //         try {\n  //             const response = await fetch(`/api/missingMessages?userId=${twilioUserId}`);\n  //             if (!response.ok) throw new Error(\"Failed to fetch missing messages\");\n  \n  //             const data = await response.json();\n  //             setHasFetchedMissing(true); // Mark as fetched\n  //             return data;\n  //         } catch (error) {\n  //             console.error(\"Error fetching missing messages:\", error);\n  //             return [];\n  //         }\n  //     };\n  \n  //     // Handle incoming WebSocket messages\n  //     const handleMessageReceived = async (event: MessageEvent) => {\n  //         if (wsonly) return; // Skip message handling if wsonly is true\n  \n  //         try {\n  //             const newMessage = JSON.parse(event.data);\n  \n  //             if (newMessage.type === \"twilio\") {\n  //                 setIncomingSms((prev) => [...prev, newMessage]);\n  //             } else if (newMessage.type === \"system\") {\n  //                 setSystemMessages((prev) => [...prev, newMessage]);\n  //             } else {\n  //                 console.warn(\"Unknown message type received:\", newMessage.type);\n  //             }\n  \n  //             // Fetch missing messages only once\n  //             if (!hasFetchedMissing) {\n  //                 const missingMessages = await fetchMissingMessages(twilioUserId);\n  //                 if (missingMessages.length > 0) {\n  //                     setMessages((prev) => [...prev, ...missingMessages]);\n  //                 }\n  //             }\n  //         } catch (err) {\n  //             console.error(\"Error parsing WebSocket message:\", err);\n  //         }\n  //     };\n  \n  //     // WebSocket event handlers\n  //     const handleOpen = () => {\n  //         console.log(\"âœ… WebSocket connection established.\");\n  //     };\n  \n  //     const handleError = () => {\n  //         console.error(\"âŒ WebSocket error. Retrying...\");\n  //     };\n  \n  //     // Establish WebSocket connection\n  //     const { ws, isConnected } = useWebSocket({\n  //         url,\n  //         onMessageReceived: handleMessageReceived,\n  //         onError: handleError,\n  //         onOpen: handleOpen,\n  //     });\n  \n  //     return { messages, incomingSms, systemMessages, isConnected, ws };\n  // };","import React, { useEffect, useState } from \"react\";\nimport ProtectedRoute from \"../components/ProtectedRoute\";\nimport { getCurrentTwilioUserId, Twilio } from \"../api/twilio\";\nimport { useWebSocket } from \"../api/websocket\";\n\n\n\nconst DOMAIN : string = 'makethemcall.me'\nconst WEBSOCKET_URL : any = `wss://${DOMAIN}/ws/`\n\nexport default () => {\n\n  const {incomingSms} = useWebSocket(WEBSOCKET_URL)\n\n  return (\n    <ProtectedRoute>\n      {(firebaseUser) => (\n        <Twilio>\n          {(twilioClient) => (\n          <>{incomingSms}</>\n          )}\n        </Twilio>\n      )}\n    </ProtectedRoute>\n)};\n\n\n\n\n"],"names":["_ref","children","user","setUser","useState","loading","setLoading","useEffect","unsubscribe","onAuthStateChanged","auth","currentUser","navigate","React","Twilio","twilioClient","setTwilioClient","undefined","async","twilio","error","console","getTwilioClient","fetchTwilioClient","reconnectWS","wsRef","url","baseReconnectDelay","maxReconnectDelay","reconnectAttemptsRef","maxAttemptsBeforeAlert","current","readyState","WebSocket","CLOSED","close","delay","Math","min","pow","warn","setTimeout","onopen","log","useWebSocket","incomingSms","setIncomingSms","useRef","_ref2","onMessageReceived","onError","onOpen","onClose","onmessage","event","data","JSON","parse","err","onerror","onclose","connectWS","prev","ProtectedRoute","firebaseUser"],"sourceRoot":""}